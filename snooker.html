<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <!-- 核心：禁止缩放，适配刘海屏 -->
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>Snooker V42 Mobile</title>
    <script src="https://unpkg.com/peerjs@1.5.2/dist/peerjs.min.js"></script>
    <style>
        * { box-sizing: border-box; -webkit-tap-highlight-color: transparent; }
        
        body {
            background-color: #121212;
            height: 100vh;
            width: 100vw;
            margin: 0;
            padding: 0;
            display: flex;
            flex-direction: column;
            align-items: center;
            /* 竖屏时靠上，横屏时居中 */
            justify-content: flex-start; 
            font-family: 'Segoe UI', Roboto, Helvetica, Arial, sans-serif;
            overflow: hidden;
            color: #eee;
        }

        /* 顶部计分板 - 自适应高度 */
        #ui-header {
            width: 100%;
            max-width: 850px;
            height: 60px;
            background: #1e1e1e;
            border-bottom: 2px solid #d4af37;
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 0 10px;
            z-index: 10;
            box-shadow: 0 4px 10px rgba(0,0,0,0.5);
            flex-shrink: 0;
        }

        .player-box {
            display: flex; flex-direction: column; align-items: center; justify-content: center;
            min-width: 50px; opacity: 0.5; transition: all 0.3s;
        }
        .player-box.active { opacity: 1; transform: scale(1.05); }
        
        .score-text { font-size: 24px; font-weight: 800; font-family: monospace; line-height: 1; color: #fff; }
        .name-text { font-size: 10px; font-weight: bold; color: #aaa; margin-top: 2px; max-width: 70px; overflow: hidden; text-overflow: ellipsis; white-space: nowrap; }
        .active .score-text { color: #ffd700; text-shadow: 0 0 10px rgba(255, 215, 0, 0.6); }
        .active .name-text { color: #d4af37; }

        #msg-area { flex: 1; text-align: center; margin: 0 5px; overflow: hidden; display: flex; flex-direction: column; justify-content: center; }
        #txt-main { font-size: 14px; font-weight: bold; color: #fff; white-space: nowrap; }
        #txt-sub { font-size: 10px; color: #888; min-height: 14px; white-space: nowrap; }
        .warn-text { color: #ff4444 !important; font-weight: bold; animation: flash 0.5s; }

        #btn-sound {
            width: 30px; height: 30px; cursor: pointer;
            background: rgba(255,255,255,0.1); border-radius: 50%; border: 1px solid #444;
            display: flex; align-items: center; justify-content: center;
        }
        #btn-sound svg { fill: #ddd; width: 16px; height: 16px; }

        /* 游戏容器 - 核心适配 */
        #game-container {
            position: relative;
            width: 100%;
            flex: 1; /* 占据剩余空间 */
            display: flex;
            align-items: center; 
            justify-content: center;
            overflow: hidden;
            padding: 10px; /* 留出一点边距 */
        }

        #canvas-box {
            position: relative;
            background: #000; 
            box-shadow: 0 10px 30px rgba(0,0,0,0.8); 
            border-radius: 4px;
            /* 默认宽度为 100% 或者最大 850px */
            width: 100%;
            max-width: 850px;
            /* 维持 2:1 比例 */
            aspect-ratio: 2/1;
        }

        canvas { display: block; width: 100%; height: 100%; border-radius: 4px; touch-action: none; }
        
        /* === 菜单系统 (响应式) === */
        #menu-overlay {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(18, 18, 18, 0.96); 
            display: flex; flex-direction: column;
            align-items: center; justify-content: center; 
            z-index: 100;
            padding: 15px;
            border-radius: 4px;
        }

        .hidden { display: none !important; }

        /* 菜单容器：支持滚动，防止竖屏溢出 */
        .menu-container {
            display: flex; flex-direction: column; align-items: center; width: 100%;
            max-height: 100%; overflow-y: auto; 
            padding: 10px 0;
        }

        .menu-logo { font-size: 26px; color: #d4af37; margin-bottom: 15px; font-weight: 900; letter-spacing: 2px; }
        
        .menu-btn {
            background: linear-gradient(135deg, #d4af37, #aa8c2c); 
            color: #000; border: none; padding: 12px 0;
            margin: 6px 0; font-size: 15px; font-weight: bold; cursor: pointer;
            border-radius: 6px; width: 80%; max-width: 240px; /* 宽度自适应 */
            box-shadow: 0 3px 5px rgba(0,0,0,0.3);
            /* 确保手机可点 */
            pointer-events: auto;
        }
        .menu-btn:active { transform: scale(0.96); opacity: 0.9; }
        .btn-secondary { background: #444; color: #fff; margin-top: 15px; }
        
        .input-group { margin-bottom: 10px; text-align: center; width: 100%; display: flex; flex-direction: column; align-items: center; }
        .input-label { color: #888; font-size: 12px; margin-bottom: 3px; }
        .input-styled {
            padding: 10px; border-radius: 6px; border: 2px solid #333; 
            background: #222; color: #fff; width: 80%; max-width: 240px;
            text-align: center; font-size: 16px; outline: none; 
        }
        .input-styled:focus { border-color: #d4af37; }

        #host-id-display {
            display: none; background: #1a1a1a; border: 1px dashed #555; 
            padding: 10px; border-radius: 8px; margin: 5px 0; width: 85%; max-width: 260px; text-align: center;
            cursor: pointer;
        }
        #host-id-val {
            font-size: 24px; font-weight: bold; color: #4CAF50; letter-spacing: 2px;
            background: transparent; border: none; width: 100%; text-align: center; 
            pointer-events: none; margin-top: 2px;
        }
        
        .status-msg { color: #aaa; font-size: 12px; margin-top: 5px; min-height: 18px; }

        #disconnect-modal {
            display: none; position: absolute; top:0; left:0; width:100%; height:100%;
            background: rgba(0,0,0,0.95); z-index: 200;
            flex-direction: column; align-items: center; justify-content: center;
        }
        .err-title { color: #ff4444; font-size: 20px; font-weight: bold; margin-bottom: 10px; }
        
        /* 横屏优化：当高度太小时 */
        @media (max-height: 400px) {
            #ui-header { height: 40px; }
            .score-text { font-size: 18px; }
            .menu-logo { font-size: 20px; margin-bottom: 5px; }
            .menu-btn { padding: 8px 0; margin: 4px 0; font-size: 14px; }
        }
    </style>
</head>
<body>

    <div id="ui-header">
        <div class="player-box" id="panel-p1">
            <span class="score-text" id="score-p1">0</span>
            <span class="name-text" id="name-p1">P1</span>
        </div>
        
        <div id="msg-area">
            <div id="txt-main"></div> 
            <div id="txt-sub"></div>
        </div>

        <div class="player-box" id="panel-p2">
            <span class="score-text" id="score-p2">0</span>
            <span class="name-text" id="name-p2">P2</span>
        </div>

        <div id="btn-sound">
            <svg id="icon-on" viewBox="0 0 24 24"><path d="M3 9v6h4l5 5V4L7 9H3zm13.5 3c0-1.77-1.02-3.29-2.5-4.03v8.05c1.48-.73 2.5-2.25 2.5-4.02zM14 3.23v2.06c2.89.86 5 3.54 5 6.71s-2.11 5.85-5 6.71v2.06c4.01-.91 7-4.49 7-8.77s-2.99-7.86-7-8.77z"/></svg>
            <svg id="icon-off" viewBox="0 0 24 24" style="display:none"><path d="M16.5 12c0-1.77-1.02-3.29-2.5-4.03v2.21l2.45 2.45c.03-.2.05-.41.05-.63zm2.5 0c0 .94-.2 1.82-.54 2.64l1.51 1.51C20.63 14.91 21 13.5 21 12c0-4.28-2.99-7.86-7-8.77v2.06c2.89.86 5 3.54 5 6.71zM4.27 3L3 4.27 7.73 9H3v6h4l5 5v-6.73l4.25 4.25c-.67.52-1.42.93-2.25 1.18v2.06c1.38-.31 2.63-.95 3.69-1.81L19.73 21 21 19.73 4.27 3zM12 4L9.91 6.09 12 8.18V4z"/></svg>
        </div>
    </div>

    <div id="game-container">
        <div id="canvas-box">
            <canvas id="gameCanvas"></canvas>
            
            <div id="menu-overlay">
                <!-- 主菜单 -->
                <div id="main-menu" class="menu-container">
                    <div class="menu-logo" id="menu-title">SNOOKER</div>
                    <div class="input-group">
                        <div class="input-label" id="lbl-your-name">Your Name</div>
                        <input type="text" id="my-name-input" class="input-styled" maxlength="8" placeholder="Name">
                    </div>
                    <button class="menu-btn" id="btn-pvc" onclick="game.startGame('PvCPU')">Vs CPU</button>
                    <button class="menu-btn" id="btn-online" onclick="ui.showOnlineMenu()" style="background: #4CAF50; color:#fff">Online</button>
                </div>

                <!-- 联机面板 -->
                <div id="online-panel" class="menu-container hidden">
                    <div class="menu-logo" id="online-title" style="font-size: 20px; margin-bottom: 10px;">Online</div>
                    <div class="input-group">
                        <button class="menu-btn" id="btn-host" onclick="network.createRoom()">Host (Create)</button>
                        <div id="host-id-display" onclick="network.copyId()">
                            <div class="input-label" id="lbl-host-id">Click to Copy ID:</div>
                            <input type="text" id="host-id-val" readonly value="">
                            <div class="status-msg" id="host-status">...</div>
                        </div>
                    </div>
                    <div style="width: 50%; height: 1px; background: #333; margin: 10px 0;"></div>
                    <div class="input-group">
                        <div class="input-label" id="lbl-join-id">Enter Friend's ID:</div>
                        <input type="text" id="join-id-input" class="input-styled" placeholder="ID" style="text-transform:uppercase;">
                        <button class="menu-btn" id="btn-join" onclick="network.joinRoom()" style="margin-top:8px">Join</button>
                        <div class="status-msg" id="join-status"></div>
                    </div>
                    <button class="menu-btn btn-secondary" id="btn-back" onclick="ui.backToMain()">Back</button>
                </div>
            </div>

            <div id="disconnect-modal">
                <div class="err-title" id="err-title">Disconnected</div>
                <div style="color:#aaa; margin-bottom: 20px; font-size:13px;" id="err-desc">Connection lost</div>
                <button class="menu-btn" id="btn-reload" onclick="location.reload()">Reload</button>
            </div>
        </div>
    </div>

<script>
// UI 控制
const ui = {
    showOnlineMenu: () => { document.getElementById('main-menu').classList.add('hidden'); document.getElementById('online-panel').classList.remove('hidden'); },
    backToMain: () => {
        if(network.peer) { network.peer.destroy(); network.peer = null; }
        document.getElementById('online-panel').classList.add('hidden');
        document.getElementById('main-menu').classList.remove('hidden');
        document.getElementById('host-id-display').style.display = 'none';
        document.getElementById('host-status').innerText = "";
        document.getElementById('join-status').innerText = "";
        document.getElementById('join-id-input').value = "";
    },
    setStatus: (id, msg) => { document.getElementById(id).innerText = msg; },
    showDisconnect: () => { document.getElementById('disconnect-modal').style.display = 'flex'; }
};

// 网络管理 (增强版连接配置)
class NetworkManager {
    constructor() { this.peer = null; this.conn = null; this.isHost = false; this.connected = false; this.opponentName = "Opponent"; }
    generateShortId() { const c='ABCDEFGHJKLMNPQRSTUVWXYZ23456789'; let r=''; for(let i=0;i<6;i++)r+=c.charAt(Math.floor(Math.random()*c.length)); return r; }
    
    // 配置公共 STUN 服务器，提高连接成功率
    initPeer(customId=null) {
        if(this.peer)return; 
        this.peer = new Peer(customId, {
            debug: 1,
            config: {
                iceServers: [
                    { urls: 'stun:stun.l.google.com:19302' },
                    { urls: 'stun:global.stun.twilio.com:3478' }
                ]
            }
        });
        
        this.peer.on('error',(err)=>{ 
            console.error(err);
            if(err.type==='unavailable-id'){this.peer=null;this.createRoom();}
            else{
                let msg = "Err: " + err.type;
                if(err.type === 'peer-unavailable') msg = "ID Not Found / Offline";
                ui.setStatus('host-status',msg); ui.setStatus('join-status',msg);
            } 
        });
        this.peer.on('disconnected',()=>{if(this.connected)ui.showDisconnect();});
    }

    createRoom() { this.initPeer(this.generateShortId()); this.isHost=true; this.peer.on('open',(id)=>{document.getElementById('host-id-display').style.display='block';document.getElementById('host-id-val').value=id;ui.setStatus('host-status',game.text.status_wait);}); this.peer.on('connection',(c)=>{this.handleConnection(c);}); }
    joinRoom() { let id=document.getElementById('join-id-input').value.trim().toUpperCase(); if(!id)return alert(game.text.alert_input_id); this.initPeer(null); this.isHost=false; ui.setStatus('join-status',game.text.connecting); this.peer.on('open',()=>{this.handleConnection(this.peer.connect(id));}); }
    
    handleConnection(conn) {
        this.conn=conn; const name=document.getElementById('my-name-input').value||game.text.default_player;
        this.conn.on('open',()=>{this.connected=true;this.send({type:'NAME_HANDSHAKE',name:name});});
        this.conn.on('data',(d)=>{this.handleData(d);});
        this.conn.on('close',()=>{ui.showDisconnect();}); this.conn.on('error',()=>{ui.showDisconnect();});
    }
    send(data) { if(this.connected&&this.conn)this.conn.send(data); }
    handleData(d) {
        switch(d.type) {
            case 'NAME_HANDSHAKE': this.opponentName=d.name; if(this.isHost){const n=document.getElementById('my-name-input').value||game.text.default_p1;this.send({type:'NAME_HANDSHAKE_ACK',name:n});ui.setStatus('host-status',game.text.friend_joined);setTimeout(()=>{game.startGame('ONLINE_HOST',n,this.opponentName);game.syncToClient();},800);} break;
            case 'NAME_HANDSHAKE_ACK': this.opponentName=d.name; const n=document.getElementById('my-name-input').value||game.text.default_p2;ui.setStatus('join-status',game.text.connected_wait);setTimeout(()=>{game.startGame('ONLINE_CLIENT',n,this.opponentName);},500); break;
            case 'SYNC_STATE': if(!this.isHost)game.applySyncState(d.payload); break;
            case 'SHOOT': game.executeShoot(d.nx,d.ny,d.power,true); break;
            case 'PLACE_CUE': if(game.state.phase==='PLACING'){game.whiteBall.x=d.x;game.whiteBall.y=d.y;game.confirmPlacement(true);} break;
        }
    }
    copyId() { const e=document.getElementById('host-id-val'); e.select(); e.setSelectionRange(0,99999); navigator.clipboard.writeText(e.value).then(()=>{ui.setStatus('host-status',game.text.id_copied);setTimeout(()=>ui.setStatus('host-status',game.text.status_wait),2000);}); }
}

const audio = {
    ctx: null, enabled: true,
    init: function() { if(!this.ctx){ this.ctx = new (window.AudioContext||window.webkitAudioContext)(); } if(this.ctx.state==='suspended')this.ctx.resume(); },
    playHit: function(f) { 
        if(!this.enabled||!this.ctx)return; const t=this.ctx.currentTime, o=this.ctx.createOscillator(), g=this.ctx.createGain(); 
        o.frequency.setValueAtTime(150,t); o.frequency.exponentialRampToValueAtTime(40,t+0.05); 
        g.gain.setValueAtTime(Math.min(f,1)*0.8,t); g.gain.exponentialRampToValueAtTime(0.01,t+0.05); 
        o.connect(g); g.connect(this.ctx.destination); o.start(); o.stop(t+0.05); 
    },
    playCushion: function(f) {
        if(!this.enabled||!this.ctx) return; const t = this.ctx.currentTime, o = this.ctx.createOscillator(), g = this.ctx.createGain();
        o.type = 'triangle'; o.frequency.setValueAtTime(120, t); o.frequency.linearRampToValueAtTime(60, t + 0.1);
        g.gain.setValueAtTime(Math.min(f,1)*0.5, t); g.gain.exponentialRampToValueAtTime(0.01, t + 0.1);
        o.connect(g); g.connect(this.ctx.destination); o.start(); o.stop(t + 0.1);
    },
    playPot: function() { 
        if(!this.enabled||!this.ctx)return; const t=this.ctx.currentTime, o=this.ctx.createOscillator(), g=this.ctx.createGain(); 
        o.frequency.setValueAtTime(80,t); g.gain.setValueAtTime(0.5,t); g.gain.exponentialRampToValueAtTime(0.01,t+0.3); 
        o.connect(g); g.connect(this.ctx.destination); o.start(); o.stop(t+0.3); 
    }
};

document.getElementById('btn-sound').addEventListener('click', (e) => { e.stopPropagation(); audio.enabled = !audio.enabled; document.getElementById('icon-on').style.display = audio.enabled ? 'block' : 'none'; document.getElementById('icon-off').style.display = audio.enabled ? 'none' : 'block'; if(audio.enabled) audio.init(); });

const TYPES = { CUE: 0, RED: 1, COLOR: 2 };
const COLS = { BALLS: { WHITE:'#f5f5f5', RED:'#cc0000', YELLOW:'#ffcc00', GREEN:'#006633', BROWN:'#663300', BLUE:'#003399', PINK:'#ff9999', BLACK:'#0a0a0a' } };
function setText(id, t) { let e=document.getElementById(id); if(e)e.innerText=t; }
function setClass(id, c, a) { let e=document.getElementById(id); if(e) a?e.classList.add(c):e.classList.remove(c); }

let game = null;
const network = new NetworkManager();
window.onload = () => { game = new GameApp(); };

class GameApp {
    constructor() {
        this.LOGICAL_W = 900; this.LOGICAL_H = 450; this.RAIL = 40;
        this.PLAY_W = this.LOGICAL_W - this.RAIL * 2; this.PLAY_H = this.LOGICAL_H - this.RAIL * 2;
        this.OFFSET = this.RAIL; this.BAULK_X = this.OFFSET + this.PLAY_W * 0.2; this.CENTER_Y = this.LOGICAL_H / 2;
        this.D_RADIUS = 60; this.BALL_R = 8.5; this.POCKET_R = 16; 
        this.canvas = document.getElementById('gameCanvas'); this.ctx = this.canvas.getContext('2d');
        if (!this.ctx.roundRect) this.ctx.roundRect = this.ctx.rect;
        this.balls = []; this.pockets = []; this.whiteBall = null;
        this.state = { mode: 'PvCPU', turn: 'P1', phase: 'PLACING', target: 'RED', scoreP1: 0, scoreP2: 0, redsLeft: 15, msg: "", tempMsg: "", mousePos: {x:0,y:0}, aiState: 'IDLE' };
        this.dragStart = null; this.setupLang(); this.initPockets(); this.handleResize();
        window.addEventListener('resize', () => this.handleResize());
        
        // 移动端操作修复：分离 UI 与 Canvas 事件
        const startHandler = (e) => {
            // 如果点的是 UI 元素，不做处理，让它触发点击
            if (e.target.closest('.menu-btn') || e.target.tagName === 'INPUT') return;
            
            // 如果点的是 Canvas 区域，则拦截默认行为（防止滚动）并初始化游戏逻辑
            e.preventDefault(); 
            audio.init(); 
            this.onInput(e.type, e);
        };
        
        // 绑定 Canvas 操作
        this.canvas.addEventListener('mousedown', startHandler);
        this.canvas.addEventListener('touchstart', startHandler, {passive: false});
        
        // 绑定移动和结束事件到 window，保证拖拽流畅
        window.addEventListener('mousemove', e => this.onInput(e.type, e));
        window.addEventListener('mouseup', e => this.onInput(e.type, e));
        window.addEventListener('touchmove', e => { if(this.dragStart) e.preventDefault(); this.onInput(e.type, e); }, {passive: false});
        window.addEventListener('touchend', e => this.onInput(e.type, e));

        requestAnimationFrame(() => this.loop());
    }

    setupLang() {
        const zh = {
            default_p1: "玩家 1", default_p2: "玩家 2", default_player: "玩家", cpu: "电脑", me: "我", opp: "对手",
            target_red: "目标: 红球 (1分)", target_any: "目标: 任意彩球", target_ball: "目标: ",
            foul: "犯规! ", score_plus: "加分 +", place: "D区内放球", drag: "拖拽击球", wait_opp: "对方回合...",
            think: "电脑思考中...", shooting: "电脑击球中...",
            wait: "运动中...", win: " 获胜!",
            menu_title: "斯诺克对决", btn_pvc: "单人 vs 电脑", btn_online: "在线双人联机", online_title: "联机对战",
            btn_host: "我是房主 (创建)", lbl_host_id: "点击 ID 复制:", status_wait: "等待连接...", id_copied: "已复制!",
            lbl_join_id: "或输入好友 ID:", btn_join: "加入游戏", btn_back: "返回",
            lbl_your_name: "你的名字", ph_your_name: "名字或昵称",
            net_err: "连接错误: ", room_created: "房间已创建，等待好友...", friend_joined: "好友已连接！",
            connecting: "正在连接...", connected_wait: "连接成功！", disconnected: "连接已断开", err_desc: "连接意外中断或对方已离开", btn_reload: "重新加载", alert_input_id: "请输入房主 ID",
            balls: ["", "", "黄球", "绿球", "棕球", "蓝球", "粉球", "黑球"]
        };
        const en = {
            default_p1: "Player 1", default_p2: "Player 2", default_player: "Player", cpu: "CPU", me: "YOU", opp: "OPPONENT",
            target_red: "Target: RED", target_any: "Target: COLOR", target_ball: "Target: ",
            foul: "FOUL! ", score_plus: "Score +", place: "Place Cue Ball", drag: "Drag to Shoot", wait_opp: "Opponent's Turn...",
            think: "Thinking...", shooting: "Shooting...",
            wait: "Rolling...", win: " WIN!",
            menu_title: "SNOOKER", btn_pvc: "Vs CPU", btn_online: "Online", online_title: "Online Match",
            btn_host: "Host Game", lbl_host_id: "Click ID to Copy:", status_wait: "Waiting...", id_copied: "Copied!",
            lbl_join_id: "Or Enter Friend's ID:", btn_join: "Join", btn_back: "Back",
            lbl_your_name: "Your Name", ph_your_name: "Name or Nickname",
            net_err: "Error: ", room_created: "Room Ready", friend_joined: "Connected!",
            connecting: "Connecting...", connected_wait: "Connected!", disconnected: "Disconnected", err_desc: "Connection lost or opponent left", btn_reload: "Reload", alert_input_id: "Enter Host ID",
            balls: ["", "", "Yellow", "Green", "Brown", "Blue", "Pink", "Black"]
        };
        this.text = (navigator.language || 'en').startsWith('zh') ? zh : en;
        setText('name-p1', this.text.default_p1); setText('name-p2', this.text.default_p2);
        setText('menu-title', this.text.menu_title); setText('lbl-your-name', this.text.lbl_your_name);
        document.getElementById('my-name-input').placeholder = this.text.ph_your_name;
        setText('btn-pvc', this.text.btn_pvc); setText('btn-online', this.text.btn_online); setText('online-title', this.text.online_title);
        setText('btn-host', this.text.btn_host); setText('lbl-host-id', this.text.lbl_host_id); setText('host-status', this.text.status_wait);
        setText('lbl-join-id', this.text.lbl_join_id); setText('btn-join', this.text.btn_join); setText('btn-back', this.text.btn_back);
        setText('err-title', this.text.disconnected); setText('err-desc', this.text.err_desc); setText('btn-reload', this.text.btn_reload);
    }

    startGame(mode, n1, n2) {
        this.state.mode = mode; document.getElementById('menu-overlay').style.display = 'none';
        const myInput = document.getElementById('my-name-input').value; const fallback = myInput?myInput:this.text.default_p1;
        if (mode === 'ONLINE_HOST') { setText('name-p1', n1); setText('name-p2', n2); }
        else if (mode === 'ONLINE_CLIENT') { setText('name-p1', n2); setText('name-p2', n1); }
        else { setText('name-p1', fallback); setText('name-p2', this.text.cpu); }
        if (mode === 'ONLINE_CLIENT') this.balls = []; else { this.resetTable(); if (mode === 'ONLINE_HOST') this.syncToClient(); }
    }

    handleResize() { const box = document.getElementById('canvas-box'); if (!box) return; const rect = box.getBoundingClientRect(); const dpr = window.devicePixelRatio || 1; this.canvas.width = rect.width * dpr; this.canvas.height = rect.height * dpr; this.ctx.setTransform(dpr, 0, 0, dpr, 0, 0); this.scaleX = rect.width / this.LOGICAL_W; this.scaleY = rect.height / this.LOGICAL_H; }
    initPockets() { const m = 40; const cx = 450; const h = 450; this.pockets = [{x:m, y:m}, {x:cx, y:m-5}, {x:900-m, y:m}, {x:m, y:h-m}, {x:cx, y:h-m+5}, {x:900-m, y:h-m}].map(p => ({x:p.x, y:p.y})); }

    resetTable() {
        this.balls = []; this.whiteBall = this.createBall(0, -999, -999, 0, 4, '#f5f5f5'); this.whiteBall.active = false; this.balls.push(this.whiteBall);
        const add = (c, v, xr, yo) => this.balls.push(this.createBall(this.balls.length, 40 + 820*xr, 225+yo, 2, v, c));
        const C = COLS.BALLS; add(C.YELLOW, 2, 0.2, 60); add(C.GREEN, 3, 0.2, -60); add(C.BROWN, 4, 0.2, 0); add(C.BLUE, 5, 0.5, 0); add(C.PINK, 6, 0.75, 0); add(C.BLACK, 7, 0.91, 0);
        let idCounter = 20; const startX = 40 + 820 * 0.75 + 17 + 4;
        for (let c=0; c<5; c++) { for (let r=0; r<=c; r++) { let x = startX + c * 15; let y = 225 - (c*8.5) + (r*17.2); this.balls.push(this.createBall(idCounter++, x+Math.random(), y+Math.random(), 1, 1, C.RED)); } }
        this.state.redsLeft = 15; this.state.phase = 'PLACING'; this.state.turn = 'P1'; this.state.scoreP1 = 0; this.state.scoreP2 = 0; this.state.target = 'RED'; this.updateUI();
    }
    createBall(id, x, y, type, val, color) { return { id, x, y, type, val, color, vx: 0, vy: 0, active: true, spotX: type===2?x:null, spotY: type===2?y:null }; }

    syncToClient(foulMsg) { if (this.state.mode !== 'ONLINE_HOST' || !network.connected) return; const payload = { balls: this.balls.map(b => ({ id:b.id, x:b.x, y:b.y, type:b.type, val:b.val, color:b.color, vx:b.vx, vy:b.vy, active:b.active })), scoreP1: this.state.scoreP1, scoreP2: this.state.scoreP2, turn: this.state.turn, phase: this.state.phase, target: this.state.target, whiteFoul: this.state.whiteFoul, redsLeft: this.state.redsLeft, tempMsg: foulMsg }; network.send({ type: 'SYNC_STATE', payload: payload }); }
    applySyncState(data) {
        if (this.balls.length === 0 && data.balls.length > 0) this.balls = data.balls.map(b => ({ id:b.id, x:b.x, y:b.y, type:b.type, val:b.val, color:b.color, vx:b.vx, vy:b.vy, active:b.active, spotX: (b.type===2?b.x:null), spotY: (b.type===2?b.y:null) }));
        else data.balls.forEach(rb => { let lb = this.balls.find(b => b.id === rb.id); if (lb) { lb.x = rb.x; lb.y = rb.y; lb.vx = rb.vx; lb.vy = rb.vy; lb.active = rb.active; } });
        this.whiteBall = this.balls.find(b => b.type === 0); this.state.scoreP1 = data.scoreP1; this.state.scoreP2 = data.scoreP2; this.state.turn = data.turn; this.state.phase = data.phase; this.state.target = data.target; this.state.redsLeft = data.redsLeft;
        if (data.tempMsg) this.showTempMsg(data.tempMsg); this.updateUI();
    }

    isMyTurn() { if (this.state.mode === 'PvCPU') return this.state.turn === 'P1'; if (this.state.mode === 'ONLINE_HOST') return this.state.turn === 'P1'; if (this.state.mode === 'ONLINE_CLIENT') return this.state.turn === 'P2'; return false; }
    getLogicPos(e) { 
        const r = this.canvas.getBoundingClientRect(); 
        let cx = e.clientX, cy = e.clientY; 
        if (e.changedTouches && e.changedTouches.length > 0) { cx = e.changedTouches[0].clientX; cy = e.changedTouches[0].clientY; } 
        return { x: (cx - r.left) / this.scaleX, y: (cy - r.top) / this.scaleY }; 
    }

    onInput(type, e) {
        // 事件已经在全局监听器中筛选过，这里直接处理逻辑
        const p = this.getLogicPos(e); 
        this.state.mousePos = p;
        if (!this.isMyTurn()) return;

        if (type === 'mousedown' || type === 'touchstart') {
            if (this.state.phase === 'PLACING' && this.isPlaceable(p)) { this.whiteBall.x = p.x; this.whiteBall.y = p.y; this.confirmPlacement(); if (network.connected) network.send({ type: 'PLACE_CUE', x: p.x, y: p.y }); }
            else if (this.state.phase === 'IDLE') this.dragStart = p;
        } else if ((type === 'mouseup' || type === 'touchend') && this.state.phase === 'IDLE' && this.dragStart) {
            let dx = this.dragStart.x - p.x, dy = this.dragStart.y - p.y, len = Math.sqrt(dx*dx + dy*dy);
            if (len > 10) this.executeShoot(dx/len, dy/len, Math.min(len/5, 25), false);
            this.dragStart = null;
        }
    }

    confirmPlacement(remote) { this.whiteBall.vx=0; this.whiteBall.vy=0; this.whiteBall.active=true; this.state.phase = 'IDLE'; this.state.tempMsg = ""; audio.playHit(0.5); this.updateUI(); if (this.state.mode === 'ONLINE_HOST' && !remote) this.syncToClient(); }
    isPlaceable(p) { const m = 48.5; if (p.x<m || p.x>900-m || p.y<m || p.y>450-m || p.x>204) return false; return Math.hypot(p.x-204, p.y-225) <= 60 && !this.balls.some(b => b.active && b!==this.whiteBall && Math.hypot(b.x-p.x, b.y-p.y) < 17); }
    executeShoot(nx, ny, p, remote) { 
        if (isNaN(nx) || isNaN(ny) || isNaN(p)) { nx = 1; ny = 0; p = 1; } 
        this.whiteBall.vx = nx * p; this.whiteBall.vy = ny * p; this.state.phase = 'MOVING'; this.state.firstHit = null; this.state.potted = []; this.state.whiteFoul = false; audio.playHit(p/25); this.updateUI(); if (!remote && network.connected) network.send({ type: 'SHOOT', nx, ny, power: p }); 
    }

    updatePhysics() {
        if (this.state.aiState === 'ANIMATING') return; 
        if (this.state.phase !== 'MOVING') return;
        
        let moving = false;
        // 增加迭代次数以提高精度，防止穿墙
        for (let s=0; s<10; s++) {
            this.balls.forEach(b => { 
                if (!b.active) return; 
                b.x += b.vx; b.y += b.vy; 
                b.vx *= 0.985; b.vy *= 0.985; // 稍微增加阻力
                if(Math.abs(b.vx) < 0.01) b.vx = 0;
                if(Math.abs(b.vy) < 0.01) b.vy = 0;
            });
            const m = 48.5; 
            this.balls.forEach(b => { if(!b.active)return; if(b.x<m){b.x=m;b.vx*=-0.65;audio.playCushion(Math.hypot(b.vx,b.vy)/10);} else if(b.x>900-m){b.x=900-m;b.vx*=-0.65;audio.playCushion(Math.hypot(b.vx,b.vy)/10);} if(b.y<m){b.y=m;b.vy*=-0.65;audio.playCushion(Math.hypot(b.vx,b.vy)/10);} else if(b.y>450-m){b.y=450-m;b.vy*=-0.65;audio.playCushion(Math.hypot(b.vx,b.vy)/10);} });
            
            for(let i=0;i<this.balls.length;i++) for(let j=i+1;j<this.balls.length;j++) {
                let b1=this.balls[i], b2=this.balls[j]; if(!b1.active||!b2.active)continue; let dx=b1.x-b2.x, dy=b1.y-b2.y, d=Math.sqrt(dx*dx+dy*dy);
                if(d<17) {
                    if(this.state.phase==='MOVING' && !this.state.firstHit) { if(b1===this.whiteBall)this.state.firstHit=b2; else if(b2===this.whiteBall)this.state.firstHit=b1; }
                    let a=Math.atan2(dy,dx), sin=Math.sin(a), cos=Math.cos(a), v1={x:b1.vx*cos+b1.vy*sin, y:b1.vy*cos-b1.vx*sin}, v2={x:b2.vx*cos+b2.vy*sin, y:b2.vy*cos-b2.vx*sin};
                    let v1f=v2.x*0.88, v2f=v1.x*0.88, ov=(17-d)/2; b1.x+=ov*Math.cos(a); b1.y+=ov*Math.sin(a); b2.x-=ov*Math.cos(a); b2.y-=ov*Math.sin(a);
                    b1.vx=v1f*cos-v1.y*sin; b1.vy=v1.y*cos+v1f*sin; b2.vx=v2f*cos-v2.y*sin; b2.vy=v2.y*cos+v2f*sin; if(Math.abs(v1.x-v2.x)>0.3)audio.playHit(Math.abs(v1.x-v2.x)/15);
                }
            }
            this.balls.forEach(b => { if(!b.active)return; for(let p of this.pockets) if(Math.hypot(b.x-p.x, b.y-p.y)<16) { b.active=false; b.vx=0; b.vy=0; if(b===this.whiteBall)this.state.whiteFoul=true; else this.state.potted.push(b); audio.playPot(); break; } });
        }

        // 外层检测：只要有一个球有速度，就认为在运动
        let isAnyBallMoving = false;
        this.balls.forEach(b => {
            if(b.active && Math.hypot(b.vx, b.vy) > 0.02) isAnyBallMoving = true;
        });

        if (!isAnyBallMoving) { 
            this.state.phase = 'IDLE'; 
            if (this.state.mode === 'ONLINE_HOST' || !this.state.mode.startsWith('ONLINE')) {
                this.settleTurn(); 
            }
        }
    }

    settleTurn() {
        let foul = false, penalty = 4, turnScore = 0, validPot = false, isRed = this.state.target === 'RED';
        let foulMsg = null;
        if (this.state.whiteFoul) { foul = true; this.whiteBall.active = false; }
        if (!foul) {
            if (!this.state.firstHit) foul = true;
            else {
                let h = this.state.firstHit;
                if (isRed && h.type !== 1) { foul = true; penalty = Math.max(4, h.val); }
                else if (this.state.target === 'COLOR' && h.type === 1) foul = true;
                else if (typeof this.state.target === 'number' && h.val !== this.state.target) { foul = true; penalty = Math.max(4, this.state.target, h.val); }
            }
        }
        if (!foul && this.state.potted.length > 0) {
            for (let b of this.state.potted) {
                let ok = false;
                if (isRed && b.type === 1) ok = true;
                else if (this.state.target === 'COLOR' && b.type === 2) ok = true;
                else if (typeof this.state.target === 'number' && b.val === this.state.target) ok = true;
                if (!ok) { foul = true; let p = Math.max(4, b.val); if (typeof this.state.target === 'number') p = Math.max(p, this.state.target); penalty = Math.max(penalty, p); } else turnScore += b.val;
            }
            if (!foul) validPot = true;
        }
        
        let reds = this.balls.filter(b => b.type === 1 && b.active).length;
        this.state.redsLeft = reds;
        this.state.potted.forEach(b => {
            if (b.type === 2) { 
                let respot = (reds > 0) || foul || (typeof this.state.target === 'number' && b.val !== this.state.target);
                if (reds === 0 && !foul && b.val === this.state.target) respot = false;
                if (respot) { b.active = true; b.x = b.spotX; b.y = b.spotY; b.vx=0; b.vy=0; while(this.balls.some(o => o!==b && o.active && Math.hypot(o.x-b.x, o.y-b.y)<17)) b.x += 2; }
            }
        });
        
        let opp = this.state.turn === 'P1' ? 'scoreP2' : 'scoreP1';
        if (foul) {
            this.state[opp] += penalty; foulMsg = `${this.text.foul} ${this.text.score_plus}${penalty}`; this.showTempMsg(foulMsg);
            const winScoreEl = document.getElementById(this.state.turn === 'P1' ? 'score-p2' : 'score-p1');
            winScoreEl.classList.add('flash-red'); setTimeout(() => winScoreEl.classList.remove('flash-red'), 500);
            this.changeTurn(this.state.whiteFoul, foulMsg);
        } else if (validPot) {
            let my = this.state.turn === 'P1' ? 'scoreP1' : 'scoreP2'; this.state[my] += turnScore;
            if (isRed) this.state.target = 'COLOR';
            else if (this.state.target === 'COLOR') { if (reds > 0) this.state.target = 'RED'; else this.state.target = 2; }
            else { this.state.target++; if (this.state.target > 7) { this.handleGameOver(); return; } }
            this.updateUI();
            if (this.state.mode === 'PvCPU' && this.state.turn === 'P2') setTimeout(() => this.startAiLogic(), 1000);
            if (this.state.mode === 'ONLINE_HOST') this.syncToClient();
        } else { this.changeTurn(false); }
    }

    handleGameOver() {
        this.state.phase = 'IDLE'; 
        let winner = this.state.scoreP1 > this.state.scoreP2 ? document.getElementById('name-p1').innerText : document.getElementById('name-p2').innerText;
        alert("GAME OVER! " + winner + " Wins!"); location.reload();
    }

    showTempMsg(msg) { this.state.tempMsg = msg; this.updateUI(); if (this.state.tempMsgTimer) clearTimeout(this.state.tempMsgTimer); this.state.tempMsgTimer = setTimeout(() => { this.state.tempMsg = ""; this.updateUI(); }, 3000); }

    changeTurn(ballInHand, foulMsg = null) {
        this.state.turn = (this.state.turn === 'P1') ? 'P2' : 'P1';
        if (this.state.redsLeft > 0) this.state.target = 'RED';
        if (ballInHand) { if (this.state.mode === 'PvCPU' && this.state.turn === 'P2') { this.cpuPlaceBall(); this.state.phase = 'IDLE'; } else { this.state.phase = 'PLACING'; } } else { this.state.phase = 'IDLE'; }
        this.updateUI();
        if (this.state.mode === 'PvCPU' && this.state.turn === 'P2' && this.state.phase === 'IDLE') setTimeout(() => this.startAiLogic(), 1500);
        if (this.state.mode === 'ONLINE_HOST') this.syncToClient(foulMsg);
    }

    cpuPlaceBall() {
        this.whiteBall.active = true; this.whiteBall.vx=0; this.whiteBall.vy=0;
        do { let a = Math.PI/2 + Math.random()*Math.PI; let r = Math.random() * 51.5; this.whiteBall.x = 204 + Math.cos(a)*r; this.whiteBall.y = 225 + Math.sin(a)*r; } while(this.balls.some(b => b!==this.whiteBall && b.active && Math.hypot(b.x-this.whiteBall.x, b.y-this.whiteBall.y) < 17));
    }

    startAiLogic() { if (this.state.turn !== 'P2') return; this.state.aiState = 'THINKING'; this.updateUI(); if (!this.whiteBall.active) this.cpuPlaceBall(); setTimeout(() => this.cpuCalculate(), 500); }
    
    cpuCalculate() {
        try {
            let targets = this.balls.filter(b => b.active && (b===this.whiteBall?false:(this.state.target==='RED'?b.type===1:(this.state.target==='COLOR'?b.type===2:b.val===this.state.target))));
            if (targets.length === 0) { this.startAiAnimation({x: 1, y: 0}, 5); return; }
            let best = null; let maxScore = -9999;
            targets.forEach(t => {
                this.pockets.forEach(p => {
                    let dx = p.x - t.x, dy = p.y - t.y; let dist = Math.hypot(dx, dy); if(dist<1)dist=1;
                    let nx = dx/dist, ny = dy/dist;
                    let sx = t.x - nx * 17 - this.whiteBall.x, sy = t.y - ny * 17 - this.whiteBall.y; let sDist = Math.hypot(sx, sy); if(sDist<1)sDist=1;
                    if ((sx*dx + sy*dy) / (sDist * dist) > 0) { let score = 1000 - sDist - dist + t.val*20; if (score > maxScore) { maxScore = score; best = { x: sx/sDist, y: sy/sDist, p: Math.min(25, sDist/15+8) }; } }
                });
            });
            if (!best) { 
                let t = targets[0]; let dx = t.x - this.whiteBall.x, dy = t.y - this.whiteBall.y; let d = Math.hypot(dx, dy); 
                if(d < 0.1) d = 1; 
                best = { x: dx/d, y: dy/d, p: 15 }; 
            }
            this.startAiAnimation(best, best.p);
        } catch(e) {
            this.startAiAnimation({x: Math.random(), y: Math.random()}, 10);
        }
    }
    
    startAiAnimation(dir, power) { 
        let dx = dir.x || 1; let dy = dir.y || 0; let p = power || 5;
        if(isNaN(dx) || isNaN(dy)) { dx=1; dy=0; }
        this.state.aiState = 'ANIMATING'; 
        this.state.aiAnimStart = Date.now(); 
        this.state.aiDir = { x: dx, y: dy }; 
        this.state.aiPower = p; 
    }

    updateUI() {
        setClass('panel-p1', 'active', this.state.turn === 'P1'); setClass('panel-p2', 'active', this.state.turn === 'P2');
        setText('score-p1', this.state.scoreP1); setText('score-p2', this.state.scoreP2);
        let txt = "";
        if (!this.isMyTurn() && this.state.mode.startsWith('ONLINE')) txt = this.text.wait_opp;
        else if (this.state.phase === 'PLACING') txt = this.text.place;
        else if (this.state.mode === 'PvCPU' && this.state.turn === 'P2') {
            if (this.state.phase === 'MOVING') txt = this.text.wait;
            else txt = (this.state.aiState === 'ANIMATING') ? this.text.shooting : this.text.think;
        }
        else if (this.state.target === 'RED') txt = this.text.target_red;
        else if (this.state.target === 'COLOR') txt = this.text.target_any;
        else txt = this.text.target_ball + this.text.balls[this.state.target];
        setText('txt-main', txt);
        if (this.state.tempMsg) { setText('txt-sub', this.state.tempMsg); document.getElementById('txt-sub').classList.add('warn-text'); } 
        else { setText('txt-sub', this.state.phase === 'IDLE' ? (this.isMyTurn() ? this.text.drag : "") : this.text.wait); document.getElementById('txt-sub').classList.remove('warn-text'); }
    }

    drawCue(ctx, sx, sy, nx, ny, pwr) {
        if(isNaN(nx) || isNaN(ny)) return;
        let cueDist = 20 + pwr * 150; let csx = sx - nx * cueDist, csy = sy - ny * cueDist;
        ctx.beginPath(); ctx.moveTo(csx, csy); ctx.lineTo(csx - nx * 300, csy - ny * 300); ctx.strokeStyle = "#deb887"; ctx.lineWidth = 6; ctx.lineCap = "round"; ctx.stroke();
        ctx.beginPath(); ctx.moveTo(csx, csy); ctx.lineTo(csx-nx*5, csy-ny*5); ctx.strokeStyle = "#333"; ctx.lineWidth = 6; ctx.stroke();
        ctx.fillStyle = "#fff"; ctx.font = "bold 12px monospace"; ctx.textAlign = "center"; ctx.textBaseline = "middle"; ctx.strokeStyle = "#000"; ctx.lineWidth = 2;
        let pTxt = Math.round(pwr * 100) + "%"; ctx.strokeText(pTxt, sx, sy - 20); ctx.fillText(pTxt, sx, sy - 20);
        ctx.beginPath();  ctx.arc(sx, sy, 14, -Math.PI/2, -Math.PI/2 + Math.PI*2*pwr); ctx.strokeStyle = `hsl(${120-120*pwr},100%,50%)`; ctx.lineWidth=3; ctx.stroke();
    }

    draw() {
        this.ctx.save(); this.ctx.scale(this.scaleX, this.scaleY); this.ctx.clearRect(0, 0, 900, 450);
        let wood = this.ctx.createLinearGradient(0, 0, 900, 0); wood.addColorStop(0, '#3e2723'); wood.addColorStop(0.5, '#5d4037'); wood.addColorStop(1, '#3e2723');
        this.ctx.fillStyle = wood; this.ctx.fillRect(0,0,900,450);
        let felt = this.ctx.createRadialGradient(450, 225, 50, 450, 225, 800); felt.addColorStop(0, '#2e7d32'); felt.addColorStop(1, '#1b4d24');
        this.ctx.fillStyle = felt; this.ctx.beginPath(); this.ctx.roundRect(40, 40, 820, 370, 0); this.ctx.fill();
        this.ctx.fillStyle = '#000'; this.pockets.forEach(p => { this.ctx.beginPath(); this.ctx.arc(p.x, p.y, 16, 0, Math.PI*2); this.ctx.fill(); });
        this.ctx.strokeStyle = "rgba(255,255,255,0.3)"; this.ctx.lineWidth = 2;
        this.ctx.beginPath(); this.ctx.moveTo(204, 40); this.ctx.lineTo(204, 410); this.ctx.stroke();
        this.ctx.beginPath(); this.ctx.arc(204, 225, 60, Math.PI*0.5, Math.PI*1.5); this.ctx.stroke();
        this.balls.forEach(b => {
            if (!b.active) return;
            this.ctx.fillStyle = b.color; this.ctx.beginPath(); this.ctx.arc(b.x, b.y, 8.5, 0, Math.PI*2); this.ctx.fill();
            this.ctx.fillStyle = "rgba(255,255,255,0.3)"; this.ctx.beginPath(); this.ctx.arc(b.x-2, b.y-2, 3, 0, Math.PI*2); this.ctx.fill();
        });
        if (this.state.phase === 'PLACING' && this.isMyTurn()) {
            let m = this.state.mousePos; if (this.isPlaceable(m)) { this.ctx.globalAlpha = 0.5; this.ctx.fillStyle = '#fff'; this.ctx.beginPath(); this.ctx.arc(m.x, m.y, 8.5, 0, Math.PI*2); this.ctx.fill(); this.ctx.globalAlpha = 1.0; }
        }
        if (this.state.phase === 'IDLE' && this.dragStart && this.isMyTurn()) {
            let m = this.state.mousePos, dx = this.dragStart.x - m.x, dy = this.dragStart.y - m.y, len = Math.hypot(dx, dy);
            if (len > 10) {
                let div = len || 1, nx = dx/div, ny = dy/div, ex = this.whiteBall.x + nx * 800, ey = this.whiteBall.y + ny * 800;
                this.ctx.beginPath(); this.ctx.moveTo(this.whiteBall.x, this.whiteBall.y); this.ctx.lineTo(ex, ey);
                this.ctx.strokeStyle = "rgba(255,255,255,0.4)"; this.ctx.setLineDash([5,5]); this.ctx.lineWidth=1; this.ctx.stroke(); this.ctx.setLineDash([]);
                this.drawCue(this.ctx, this.whiteBall.x, this.whiteBall.y, nx, ny, Math.min(len/5, 25)/25);
            }
        }
        if (this.state.mode === 'PvCPU' && this.state.turn === 'P2' && this.state.aiState === 'ANIMATING') {
            let now = Date.now(), elapsed = now - this.state.aiAnimStart;
            this.updateUI(); // Ensure UI updates during animation
            if (elapsed < 1200) { let val = Math.sin((elapsed/1200) * Math.PI / 2); this.drawCue(this.ctx, this.whiteBall.x, this.whiteBall.y, this.state.aiDir.x, this.state.aiDir.y, (this.state.aiPower/25)*val); }
            else { this.state.aiState = 'IDLE'; this.executeShoot(this.state.aiDir.x, this.state.aiDir.y, this.state.aiPower, false); }
        }
        this.ctx.restore();
    }
    loop() { this.updatePhysics(); this.draw(); requestAnimationFrame(() => this.loop()); }
}
</script>
</body>
</html>